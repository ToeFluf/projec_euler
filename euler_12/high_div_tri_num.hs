{-
Project Euler 12: Highly Divisible triangle numbers
Author: Daniel Schmidt
Date: 06/05/2020

Background:


The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

so, a triangle number hs the form: t = SUM(i=1 to n){ i } = (n*(n+1))/2
let d(x) be a function that gets the number of divisors of a number x

So, d(t) > m, where m is the number of divisors we want to at least have

A way of representing d(x) is by multiplying the exponent of the prime factorization of x st
d(x) = PRODUCT(i to n){ a_i + 1 } where a_i is a prime factor of x

So how many prime factos do we need to get a solution? the maximum we need is when each prime factor of x has an exponent of 1

d(x) = PRODUCT(i to s){ 1 + 1 } > m

d(x) = 2^s > m
s > log2(m); if m is not a power of 2, we need ceiling(log2(m)) prime numbers; if m is a power of 2 then we need log2(m) + 1 prime numbers

Now to solve this problem, we basically use t as a generator and multiply its prime factorizations together

TAKE STUFF FROM DIO RECIP 2!!! Then just check to see if it works

n^2 + n - 2x = 0
n = (sqrt(1 + 8x) - 1)/2
-}

import  Data.List           (group, sort, sortBy, (\\))
import  Control.Applicative (liftA2)
import  System.Environment

-- usage: gen_func s n ps
-- s is the search value: for the solution 28, it is >= 5
-- n is the iteration for the triangle summation
-- ps is a list of prime values, should be the sieve_aroth [2..(ceiling $ logBase 2 s)] for values greater than 10, otherwise, just use sieve_aroth [2..25] 

func :: Int -> [Int] -> [Int]
func x ms = case go of
    (Just ls) -> ls
    Nothing -> []
    where
        go = sequence $ factorization x ms

sieve_aroth :: [Int] -> [Int]
sieve_aroth [] = []
sieve_aroth (y:ys) = y : (sieve_aroth $ filter (\m -> (mod m y) /= 0) ys)

sg :: Ord a => [a] -> [[a]]
sg = group . sort

lh :: [a] -> (a, Int)
lh = liftA2 (,) head length

count :: Ord a => [a] -> [(a, Int)]
count = map lh . sg

factorization :: Int -> [Int] -> [Maybe Int]
factorization _ [] = Nothing : []
factorization x (y:ys)  | x == 1 = []
                        | (mod x y) /= 0 = factorization x ys
                        | otherwise = (Just y) : (factorization (div x y) (y:ys))

gen_func s n ps -- | t ^ 2 <= (ceiling $ sqrt $ fromIntegral m) = gen_func s n (sieve_aroth $ ps ++ [t..(2*t)])
                | e >= s = m
                | otherwise = gen_func s (n+1) ps
                where
                    t = (tail ps) !! 0
                    m = div (n * (n + 1)) 2
                    f = count $ func m ps
                    e = foldr (\ (a,b) -> (*) (b + 1)) 1 f
